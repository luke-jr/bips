==BOLT #7: P2P Node and Channel Discovery==

This specification describes simple node discovery, channel discovery, and channel update mechanisms that do not rely on a third-party to disseminate the information.

Node and channel discovery serve two different purposes:

 - Channel discovery allows the creation and maintenance of a local view of the network's topology, so that the node can discover routes to the desired destination.
 - Node discovery allows nodes to broadcast their ID, host, and port, so that other nodes can open connections and establish payment channels.
 
To support channel discovery, peers in the network exchange
<code>channel_announcement</code> messages, which contain information about new
channels between two nodes. They can also exchange <code>channel_update</code>
messages, which update information about a channel. There can only be
one valid <code>channel_announcement</code> for any channel, but at least two
<code>channel_update</code> messages are expected.

To support node discovery, peers exchange <code>node_announcement</code>
messages, which supply additional information about nodes. There can be
multiple <code>node_announcement</code> messages, to update node information.

==Table of Contents==

<pre>
* [[#the-announcement_signatures-message|The <code>announcement_signatures</code> Message]]
* [[#the-channel_announcement-message|The <code>channel_announcement</code> Message]]
* [[#the-node_announcement-message|The <code>node_announcement</code> Message]]
* [[#the-channel_update-message|The <code>channel_update</code> Message]]
* [[#initial-sync|Initial Sync]]
* [[#rebroadcasting|Rebroadcasting]]
* [[#htlc-fees|HTLC Fees]]
* [[#pruning-the-network-view|Pruning the Network View]]
* [[#recommendations-for-routing|Recommendations for Routing]]
* [[#references|References]]
</pre>

===The <code>announcement_signatures</code> Message===

This is a direct message between two endpoints of a channel and serves as an opt-in mechanism to allow the announcement of the channel to the rest of the network.
It contains the necessary signatures by the sender to construct the <code>channel_announcement</code> message.

1. type: 259 (<code>announcement_signatures</code>)
2. data:
    * [<code>32</code>:<code>channel_id</code>]
    * [<code>8</code>:<code>short_channel_id</code>]
    * [<code>64</code>:<code>node_signature</code>]
    * [<code>64</code>:<code>bitcoin_signature</code>]

The willingness of the initiating node to announce the channel is signaled during channel opening by setting the <code>announce_channel</code> bit in <code>channel_flags</code> (see [[bip-0202.mediawiki#the-open_channel-message|BOLT #2]]).

====Requirements====

The <code>announcement_signatures</code> message is created by constructing a <code>channel_announcement</code> message, corresponding to the newly established channel, and signing it with the secrets matching an endpoint's <code>node_id</code> and <code>bitcoin_key</code>. The message is then sent using an <code>announcement_signatures</code>.

The <code>short_channel_id</code> is the unique description of the funding transaction.
It is constructed with the most significant 3 bytes indicating the block
height, the next 3 bytes indicating the transaction index within the
block, and the least significant two bytes indicating the output
index that pays to the channel.

If the <code>open_channel</code> message had the <code>announce_channel</code> bit set, then both nodes MUST send the <code>announcement_signatures</code> message, otherwise they MUST NOT.

If sent, <code>announcement_signatures</code> messages MUST NOT be sent until <code>funding_locked</code> has been sent and the funding transaction has at least six confirmations.

The recipient MAY fail the channel if the <code>node_signature</code> or <code>bitcoin_signature</code> is incorrect.
The recipient SHOULD queue the <code>channel_announcement</code> message for its peers if it has sent and received a valid <code>announcement_signatures</code> message.

On reconnection, a node SHOULD retransmit the <code>announcement_signatures</code> message if it has not received an <code>announcement_signatures</code> message, and MUST respond to the first <code>announcement_signatures</code> message after reconnection with its own <code>announcement_signatures</code> message.

===The <code>channel_announcement</code> Message===

This message contains ownership information about a channel. It ties
each on-chain Bitcoin key to the Lightning node key, and vice-versa.
The channel is not really usable until at least one side has announced
its fee levels and expiry using <code>channel_update</code>.

Proving the existence of a channel between <code>node_1</code> and
<code>node_2</code> requires:

1. proving that the funding transaction pays to <code>bitcoin_key_1</code> and
   <code>bitcoin_key_2</code>
2. proving that <code>node_1</code> owns <code>bitcoin_key_1</code>
3. proving that <code>node_2</code> owns <code>bitcoin_key_2</code>

The first proof is accomplished by assuming that all nodes know the unspent
transaction outputs, and thus can find the output given by
<code>short_channel_id</code> and validate that it is indeed a P2WSH funding
transaction output for those keys specified in
[[bip-0203.mediawiki#funding-transaction-output|BOLT #3]].

The second two proofs are accomplished through explicit signatures (<code>bitcoin_signature_1</code>
and <code>bitcoin_signature_2</code>, generated by each <code>bitcoin_key</code> and signing
the corresponding <code>node_id</code>).

It is also necessary to prove that <code>node_1</code> and <code>node_2</code> both agree on this
announcement message; this is accomplished by having a signature from each
<code>node_id</code> signing the message (<code>node_signature_1</code> and
<code>node_signature_2</code>).

1. type: 256 (<code>channel_announcement</code>)
2. data:
    * [<code>64</code>:<code>node_signature_1</code>]
    * [<code>64</code>:<code>node_signature_2</code>]
    * [<code>64</code>:<code>bitcoin_signature_1</code>]
    * [<code>64</code>:<code>bitcoin_signature_2</code>]
    * [<code>2</code>:<code>len</code>]
    * [<code>len</code>:<code>features</code>]
    * [<code>32</code>:<code>chain_hash</code>]
    * [<code>8</code>:<code>short_channel_id</code>]
    * [<code>33</code>:<code>node_id_1</code>]
    * [<code>33</code>:<code>node_id_2</code>]
    * [<code>33</code>:<code>bitcoin_key_1</code>]
    * [<code>33</code>:<code>bitcoin_key_2</code>]

====Requirements====

The creating node MUST set <code>chain_hash</code> to the 32-byte hash that uniquely
identifies the chain that the channel was opened within. For the Bitcoin
blockchain, the <code>chain_hash</code> value MUST be (encoded in hex):
<code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>.

The creating node MUST set <code>short_channel_id</code> to refer to the confirmed
funding transaction as specified in [[bip-0202.mediawiki#the-funding_locked-message|BOLT #2]]. The corresponding output MUST be a
P2WSH as described in [[bip-0203.mediawiki#funding-transaction-output|BOLT #3]].

The creating node MUST set <code>node_id_1</code> and <code>node_id_2</code> to the public
keys of the two nodes who are operating the channel, such that
<code>node_id_1</code> is the numerically-lesser of the two DER-encoded keys sorted in
ascending numerical order, and MUST set <code>bitcoin_key_1</code> and
<code>bitcoin_key_2</code> to <code>funding_pubkey</code>s of <code>node_id_1</code> and <code>node_id_2</code>
respectively.

The creating node MUST compute the double-SHA256 hash <code>h</code> of the message, starting at offset 256, up to the end of the message.
Thus the hash skips the 4 signatures, but hashes the rest of the message, including any future fields appended to the end.
<code>node_signature_1</code> and <code>node_signature_2</code> MUST be valid signatures of the hash <code>h</code> using the secret associated with <code>node_id_1</code> and <code>node_id_2</code> respectively.
<code>bitcoin_signature_1</code> and <code>bitcoin_signature_2</code> MUST be valid signatures of the hash <code>h</code> using the secret associated with <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code> respectively.

The creating node SHOULD set <code>len</code> to the minimum length required to
hold the <code>features</code> bits it sets.

The receiving node MUST verify the integrity and authenticity of the message by verifying the signatures.
If there is an unknown even bit in the <code>features</code> field the receiving node MUST NOT parse the remainder of the message and MUST NOT add the channel to its local network view, and SHOULD NOT forward the announcement.

The receiving node MUST ignore the message if the output specified
by <code>short_channel_id</code> does not
correspond to a P2WSH using <code>bitcoin_key_1</code> and <code>bitcoin_key_2</code> as
specified in [[bip-0203.mediawiki#funding-transaction-output|BOLT #3]].
The receiving node MUST ignore the message if this output is spent.

The receiving node MUST ignore the message if the specified <code>chain_hash</code>
is unknown to the receiver.

Otherwise, the receiving node SHOULD fail the connection if
<code>bitcoin_signature_1</code>, <code>bitcoin_signature_2</code>, <code>node_signature_1</code> or
<code>node_signature_2</code> are invalid or not correct.

Otherwise, if <code>node_id_1</code> or <code>node_id_2</code> are blacklisted, it SHOULD
ignore the message.

Otherwise, if the transaction referred to was not previously announced
as a channel, the receiving node SHOULD queue the message for
rebroadcasting, but MAY choose not to for messages longer than
the minimum expected length. If it has previously received a valid
<code>channel_announcement</code> for the same transaction in the same block, but
for a different <code>node_id_1</code> or <code>node_id_2</code>, it SHOULD blacklist the
previous message's <code>node_id_1</code> and <code>node_id_2</code> as well as this
<code>node_id_1</code> and <code>node_id_2</code> and forget channels connected to them,
otherwise it SHOULD store this <code>channel_announcement</code>.

The receiving node SHOULD forget a channel once its funding output has
been spent or reorganized out.

====Rationale====

Requiring both nodes to sign indicates they are both willing to route
other payments via this channel (i.e. be part of the public network).
Requiring the Bitcoin signatures proves that they control the channel.

The blacklisting of conflicting nodes disallows multiple
different announcements: no node should ever do this, as it implies
that keys have leaked.

While channels shouldn't be advertised before they are sufficiently
deep, the requirement against rebroadcasting only applies if the
transaction hasn't moved to a different block.

To avoid having to store excessive-sized messages, yet allow
reasonable expansion in future, nodes are allowed to restrict
rebroadcasting (perhaps statistically).

New channel features are possible in future; backwards compatible (or
optional) ones will have odd feature bits, incompatible ones will have
even feature bits ([[bip-0200.mediawiki#glossary-and-terminology-guide|"It's OK to be odd!"]]).
Incompatible features will result in the announcement not being forwarded by nodes that don't understand them.

===The <code>node_announcement</code> Message===

This allows a node to indicate extra data associated with it, in
addition to its public key. To avoid trivial denial of service attacks,
nodes for which a channel is not already known are ignored.

1. type: 257 (<code>node_announcement</code>)
2. data:
   * [<code>64</code>:<code>signature</code>]
   * [<code>2</code>:<code>flen</code>]
   * [<code>flen</code>:<code>features</code>]
   * [<code>4</code>:<code>timestamp</code>]
   * [<code>33</code>:<code>node_id</code>]
   * [<code>3</code>:<code>rgb_color</code>]
   * [<code>32</code>:<code>alias</code>]
   * [<code>2</code>:<code>addrlen</code>]
   * [<code>addrlen</code>:<code>addresses</code>]

The <code>timestamp</code> allows ordering in the case of multiple announcements;
the <code>rgb_color</code> and <code>alias</code> allow
intelligence services to give their nodes cool monikers like IRATEMONK
and WISTFULTOLL and use the color black.

<code>addresses</code> allows the node to announce its willingness to accept
incoming network connections: it contains series of <code>address
descriptor</code>s for connecting to the node. The first byte describes the
address type, followed by the appropriate number of bytes for that type.

The following <code>address descriptor</code> types are defined:

<pre>
* <code>0</code>: padding. data = none (length 0).
* <code>1</code>: ipv4. data = <code>[4:ipv4_addr][2:port]</code> (length 6)
* <code>2</code>: ipv6. data = <code>[16:ipv6_addr][2:port]</code> (length 18)
* <code>3</code>: tor v2 onion service. data = <code>[10:onion_addr][2:port]</code> (length 12)
    * Version 2 onion service addresses. Encodes an 80-bit truncated <code>SHA-1</code> hash
      of a 1024-bit <code>RSA</code> public key for the onion service (a.k.a. Tor hidden service).
* <code>4</code>: tor v3 onion service. data <code>[35:onion_addr][2:port]</code>  (length 37)
    * Version 3 ([https://gitweb.torproject.org/torspec.git/tree/proposals/224-rend-spec-ng.txt prop224])
      onion service addresses. Encodes: <code>[32:32_byte_ed25519_pubkey] || [2:checksum] || [1:version]</code>. 
          where <code>checksum = sha3(".onion checksum" | pubkey || version)[:2]</code>
</pre>

====Requirements====

The creating node MUST set <code>timestamp</code> to be greater than that for any previous
<code>node_announcement</code> it has created. It MAY base it on a UNIX
timestamp. It MUST set <code>signature</code> to the signature of
the double-SHA256 of the entire remaining packet after <code>signature</code>, using the
key given by <code>node_id</code>. It MAY set <code>alias</code> and <code>rgb_color</code> to customize the node's appearance in maps and graphs, where the first byte of <code>rgb</code> is the red value, the second byte is the green value and the last byte is the blue value. It MUST set <code>alias</code> to a valid UTF-8 string, with any <code>alias</code> bytes following equal to zero.

The creating node SHOULD fill <code>addresses</code> with an address descriptor
for each public network address that expects incoming connections,
and MUST set <code>addrlen</code> to the number of bytes in <code>addresses</code>.
Non-zero typed address descriptors MUST be placed in ascending order;
any number of zero-typed address descriptors MAY be placed anywhere,
but SHOULD only be used for aligning fields following <code>addresses</code>.

The creating node MUST NOT create a type 1 or type 2 address
descriptor with <code>port</code> equal to zero, and SHOULD ensure <code>ipv4_addr</code>
and <code>ipv6_addr</code> are routable addresses. The creating node MUST NOT include
more than one <code>address descriptor</code> of the same type.

The creating node SHOULD set <code>flen</code> to the minimum length required to
hold the <code>features</code> bits it sets.

The receiving node SHOULD fail the connection if <code>node_id</code> is not a valid
compressed public key, and MUST NOT further process the message.

The receiving node SHOULD fail the connection if <code>signature</code> is not a
valid signature using <code>node_id</code> of the double-SHA256 of the entire
message following the <code>signature</code> field (including unknown fields
following <code>alias</code>), and MUST NOT further process the message.

If the <code>features</code> field contains unknown even bits the receiving node MUST NOT parse the remainder of the message and MAY discard the message altogether.
The node MAY forward <code>node_announcement</code>s that contain unknown <code>features</code> bit set, even though it hasn't parsed the announcement.

The receiving node SHOULD ignore the first <code>address descriptor</code> that
does not match the types defined above. The receiving node SHOULD
fail the connection if <code>addrlen</code> is insufficient to hold the address
descriptors of the known types.

The receiving node SHOULD ignore <code>ipv6_addr</code> or <code>ipv4_addr</code>
if <code>port</code> is zero.

The receiving node SHOULD ignore the message if <code>node_id</code> is not
previously known from a <code>channel_announcement</code> message, or if
<code>timestamp</code> is not greater than the last-received
<code>node_announcement</code> from this <code>node_id</code>. Otherwise, if the
<code>timestamp</code> is greater than the last-received <code>node_announcement</code> from
this <code>node_id</code> the receiving node SHOULD queue the message for
rebroadcasting, but MAY choose not to for messages longer than
the minimum expected length.

The receiving node SHOULD NOT connect to a node which has an unknown
<code>features</code> bit set in the <code>node_announcement</code> that is even.

The receiving node MAY use <code>rgb_color</code> and <code>alias</code> to reference nodes in interfaces, but SHOULD insinuate their self-signed origin.

====Rationale====

New node features are possible in the future; backwards compatible (or
optional) ones will have odd feature bits, incompatible ones will have
even feature bits. These may be propagated by nodes even if they
can't use the announcements themselves.

New address types can be added in the future; as address descriptors have
to be ordered in ascending order, unknown ones can be safely ignored.
Future fields beyond <code>addresses</code> can still be added, optionally with
padding within <code>addresses</code> if they require certain alignment.

===The <code>channel_update</code> Message===

After a channel has been initially announced, each side independently
announces the fees and minimum expiry delta it requires to relay HTLCs
through this channel. Each uses the 8-byte
channel shortid that matches the <code>channel_announcement</code> and 1 bit
in the <code>flags</code> field
to indicate which end this is. A node can do this multiple times, if
it wants to change fees.

Note that the <code>channel_update</code> message is only useful in the context 
of ''relaying'' payments, not ''sending'' payments. When making a payment
 <code>A</code> -> <code>B</code> -> <code>C</code> -> <code>D</code>, only the <code>channel_update</code>s related to channels 
 <code>B</code> -> <code>C</code> (announced by <code>B</code>) and <code>C</code> -> <code>D</code> (announced by <code>C</code>) will 
 come into play. When building the route, amounts and expiries for HTLCs need
 to be calculated backward from the destination to the source. The initial
 exact value for <code>amount_msat</code> and minimal value for <code>cltv_expiry</code>, which are
  to be used for the last HTLC in the route, are provided in the payment request
 (see [[bip-0211.mediawiki#tagged-fields|BOLT #11]]).

A node MAY still create a <code>channel_update</code> to communicate the channel parameters to the other endpoint, even though the channel has not been announced, e.g., because the <code>announce_channel</code> bit was not set.

For further privacy such a <code>channel_update</code> MUST NOT be forwarded to other peers.
Note that such a <code>channel_update</code> that is not preceded by a <code>channel_announcement</code> is invalid to any other peer and would be discarded.

1. type: 258 (<code>channel_update</code>)
2. data:
    * [<code>64</code>:<code>signature</code>]
    * [<code>32</code>:<code>chain_hash</code>]
    * [<code>8</code>:<code>short_channel_id</code>]
    * [<code>4</code>:<code>timestamp</code>]
    * [<code>2</code>:<code>flags</code>]
    * [<code>2</code>:<code>cltv_expiry_delta</code>]
    * [<code>8</code>:<code>htlc_minimum_msat</code>]
    * [<code>4</code>:<code>fee_base_msat</code>]
    * [<code>4</code>:<code>fee_proportional_millionths</code>]

The <code>flags</code> bitfield is used to indicate the direction of the channel this update concerns: it identifies the node that this update originated from and signals various options concerning the channel.
The following table specifies the meaning of the individual bits:

| Bit Position  | Name        | Meaning                          |
| ------------- | ----------- | -------------------------------- |
| 0             | <code>direction</code> | Direction this update refers to. |
| 1             | <code>disable</code>   | Disable the channel.             |

====Requirements====

The creating node MUST set <code>signature</code> to the signature of the
double-SHA256 of the entire remaining packet after <code>signature</code>, using its own <code>node_id</code>.

The creating node MUST set <code>chain_hash</code> and <code>short_channel_id</code> to match the
32-byte hash and 8-byte channel ID that uniquely identifies the channel within
the <code>channel_announcement</code> message.  

The creating node MUST set the <code>direction</code> bit of <code>flags</code> to 0 if the creating node is <code>node_id_1</code> in that message, otherwise 1.
Bits which are not assigned a meaning must be set to 0.

A node MAY create and send a <code>channel_update</code> with the <code>disable</code> bit set to signal the temporary unavailability of a channel, e.g., due to loss of connectivity, or the permanent unavailability, e.g., ahead of an on-chain settlement.
A subsequent <code>channel_update</code> with the <code>disable</code> bit unset MAY re-enable the channel.

The creating node MUST set <code>timestamp</code> to greater than zero, and MUST set it to greater than any previously-sent <code>channel_update</code> for this <code>short_channel_id</code>.
It MUST set <code>cltv_expiry_delta</code> to the number of blocks it will subtract from an incoming HTLCs <code>cltv_expiry</code>. It MUST set <code>htlc_minimum_msat</code> to the minimum HTLC value the other end of the channel will accept, in millisatoshi. It MUST set <code>fee_base_msat</code> to the base fee it will charge for any HTLC, in millisatoshi, and <code>fee_proportional_millionths</code> to the amount it will charge per transferred satoshi in millionths of a satoshi.

The receiving nodes MUST ignore the <code>channel_update</code> if it does not correspond to one of its own channels, if the <code>short_channel_id</code> does not match a previous <code>channel_announcement</code>, or if the channel has been closed in the meantime.
It SHOULD accept <code>channel_update</code>s for its own channels in order to learn the other end's forwarding parameters, even for non-public channels.

The <code>node_id</code> for the signature verification is taken from the corresponding <code>channel_announcement</code>: <code>node_id_1</code> if the least-significant bit of flags is 0 or <code>node_id_2</code> otherwise.
The receiving node SHOULD fail the connection if <code>signature</code> is not a
valid signature using <code>node_id</code> of the double-SHA256 of the entire
message following the <code>signature</code> field (including unknown fields
following <code>fee_proportional_millionths</code>), and MUST NOT further process the message.

The receiving node MUST ignore the channel update if the specified
<code>chain_hash</code> value is unknown, meaning it isn't active on the specified
chain.

The receiving node SHOULD ignore the message if <code>timestamp</code>
is not greater than that of the last-received <code>channel_announcement</code> for
this <code>short_channel_id</code> and <code>node_id</code>. Otherwise, if the <code>timestamp</code> is equal to
the last-received <code>channel_announcement</code> and the fields other than
<code>signature</code> differ, the node MAY blacklist this <code>node_id</code> and forget all
channels associated with it. Otherwise the receiving node SHOULD
queue the message for rebroadcasting, but MAY choose not to for
messages longer than the minimum expected length.

===Initial Sync===

Upon establishing a connection, the two endpoints negotiate whether to perform an initial sync by setting the <code>initial_routing_sync</code> flags in the <code>init</code> message.
The endpoint SHOULD set the <code>initial_routing_sync</code> flag if it requires a full copy of the other endpoint's routing state.
Upon receiving an <code>init</code> message with the <code>initial_routing_sync</code> flag set, the node sends <code>channel_announcement</code>s, <code>channel_update</code>s and <code>node_announcement</code>s for all known channels and nodes as if they were just received. 

If the <code>initial_routing_sync</code> flag is not set, or initial sync was completed, then the node resumes normal operation: see the _Rebroadcasting_ section for details.

===Rebroadcasting===

Nodes receiving a new <code>channel_announcement</code> or a <code>channel_update</code> or
<code>node_announcement</code> with an updated timestamp SHOULD update their local view of the network's topology accordingly.

If, after applying the changes from the announcement, there are no channels associated with the announcing node, then the receiving node MAY purge the announcing node from the set of known nodes.
Otherwise the receiving node updates the metadata and stores the signature associated with the announcement.
This will later allow the receiving node to rebuild the announcement for its peers.

Once the announcement has been processed, it is added to a list of outgoing announcements for the processing node's peers, perhaps replacing older updates. This list will be flushed at regular intervals.
This store-and-delayed-forward broadcast is called a _staggered broadcast_

====Requirements====

Each node SHOULD flush outgoing announcements once every 60 seconds, independently of the arrival times of announcements, resulting in a staggered announcement and deduplication of announcements.

Nodes MAY re-announce their channels regularly, however this is discouraged in order to keep the resource requirements low.

Nodes SHOULD send all <code>channel_announcement</code> messages followed by the
latest <code>node_announcement</code> and <code>channel_update</code> messages upon
connection establishment.

====Rationale====

Batching announcements forms a natural rate limit with low overhead.

The sending of all announcements on reconnection is naive, but simple,
and allows bootstrapping for new nodes as well as updating for nodes that
have been offline for some time.

===HTLC Fees===

The node creating <code>channel_update</code> SHOULD accept HTLCs that pay a fee equal or greater than:

<pre>
fee_base_msat + ( amount_msat '' fee_proportional_millionths / 1000000 )
</pre>

The node creating <code>channel_update</code> SHOULD accept HTLCs that pay an
older fee for some time after sending <code>channel_update</code>, to allow for
propagation delay.

===Pruning the Network View===

Nodes SHOULD monitor the funding transactions in the blockchain to identify channels that are being closed.
If the funding output of a channel is being spent, then the channel is to be considered closed and SHOULD be removed from the local network view.

Nodes MAY prune nodes added through <code>node_announcement</code> messages from their local view if the announced node no longer has any associated open channels.
This is a direct result from the dependency of a <code>node_announcement</code> being preceded by a <code>channel_announcement</code>.

====Recommendation on Pruning Stale Entries====

Several scenarios may result in channels becoming unusable and the endpoints unable to send updates for these channels.
For example, this happens in the case where both endpoints lose access to their private keys and cannot sign a <code>channel_update</code> nor close the channel on-chain.
These channels are unlikely to be part of a computed route since they would be partitioned off from the rest of the network, however they would remain in the local network view and information on them would be forwarded to other nodes forever.
For this reason, nodes MAY prune channels should the timestamp of the latest <code>channel_update</code> be older than 2 weeks (1209600 seconds).
In addition nodes MAY ignore channels with a timestamp older than 2 weeks.
Notice that this is a node policy and MUST NOT be enforced by peers, e.g., by closing channels when receiving outdated gossip messages.

===Recommendations for Routing===

When calculating a route for an HTLC, the <code>cltv_expiry_delta</code> and the fee both
need to be considered: the <code>cltv_expiry_delta</code> contributes to the time that funds
will be unavailable on worst-case failure. The tradeoff between these
two is unclear, as it depends on the reliability of nodes.

If a route is computed by simply routing to the intended recipient, summing up the <code>cltv_expiry_delta</code>s, then nodes along the route may guess their position in the route.
Knowing the CLTV of the HTLC and the surrounding topology with the <code>cltv_expiry_delta</code>s gives an attacker a way to guess the intended recipient.
Therefore it is highly suggested to add a random offset to the CLTV that the intended recipient will receive, bumping all CLTVs along the route.
In order to create a plausible offset the sender MAY start a limited random walk on the graph, starting from the intended recipient, sum the <code>cltv_expiry_delta</code>s, and then use the sum as the offset.
This effectively creates a _shadow route extension_ to the actual route, providing better protection against this kind of attack than simply picking a random offset.

Other more advanced considerations involve diversity of routes to
avoid single points of failure and detection and channel balance
of local channels.

====Routing Example====

Consider four nodes:


<pre>
```
   B
  / \
 /   \
A     C 
 \   /
  \ /
   D
</pre>
```

Each advertises the following <code>cltv_expiry_delta</code> on its end of every
channel:

1. A: 10 blocks
2. B: 20 blocks
3. C: 30 blocks
4. D: 40 blocks

C also uses a<code>min_final_cltv_expiry</code> of 9 (the default) when requesting
payments.

Also, each node has a set fee scheme that it uses for each of its
channels:

1. A: 100 base + 1000 millionths
2. B: 200 base + 2000 millionths
3. C: 300 base + 3000 millionths
4. D: 400 base + 4000 millionths

The network will see eight <code>channel_update</code> messages:

1. A->B: <code>cltv_expiry_delta</code> = 10, <code>fee_base_msat</code> = 100, <code>fee_proportional_millionths</code> = 1000
1. A->D: <code>cltv_expiry_delta</code> = 10, <code>fee_base_msat</code> = 100, <code>fee_proportional_millionths</code> = 1000
1. B->A: <code>cltv_expiry_delta</code> = 20, <code>fee_base_msat</code> = 200, <code>fee_proportional_millionths</code> = 2000
1. D->A: <code>cltv_expiry_delta</code> = 40, <code>fee_base_msat</code> = 400, <code>fee_proportional_millionths</code> = 4000
1. B->C: <code>cltv_expiry_delta</code> = 20, <code>fee_base_msat</code> = 200, <code>fee_proportional_millionths</code> = 2000
1. D->C: <code>cltv_expiry_delta</code> = 40, <code>fee_base_msat</code> = 400, <code>fee_proportional_millionths</code> = 4000
1. C->B: <code>cltv_expiry_delta</code> = 30, <code>fee_base_msat</code> = 300, <code>fee_proportional_millionths</code> = 3000
1. C->D: <code>cltv_expiry_delta</code> = 30, <code>fee_base_msat</code> = 300, <code>fee_proportional_millionths</code> = 3000

*''B->C.'''' If B were to send 4,999,999 millisatoshi directly to C, it wouldn't
charge itself a fee nor add its own <code>cltv_expiry_delta</code>, so it would
use C's requested <code>min_final_cltv_expiry</code> of 9. Assume it also adds a
"shadow route" to give an extra CLTV of 42. It could additionally add extra
CLTV deltas at other hops, as these values are a minimum, but it doesn't
here for simplicity:

<pre>
* <code>amount_msat</code>: 4999999
* <code>cltv_expiry</code>: current-block-height + 9 + 42
* <code>onion_routing_packet</code>:
  * <code>amt_to_forward</code> = 4999999
  * <code>outgoing_cltv_value</code> = current-block-height + 9 + 42
</pre>

*''A->B->C.'''' If A were to send an 4,999,999 millisatoshi to C via B, it needs to
pay B the fee it specified in the B->C <code>channel_update</code>, calculated as
per [[#htlc_fees|HTLC Fees]]:

<pre>
fee_base_msat + ( amount_msat '' fee_proportional_millionths / 1000000 )
</pre>

	200 + ( 4999999 '' 2000 / 1000000 ) = 10199

Similarly, it would need to add the <code>cltv_expiry</code> from B->C's
<code>channel_update</code> (20), plus C's requested <code>min_final_cltv_expiry</code> (9), plus 42 for the
"shadow route".  Thus the <code>update_add_htlc</code> message from A to B would
be:

<pre>
* <code>amount_msat</code>: 5010198
* <code>cltv_expiry</code>: current-block-height + 20 + 9 + 42
* <code>onion_routing_packet</code>:
  * <code>amt_to_forward</code> = 4999999
  * <code>outgoing_cltv_value</code> = current-block-height + 9 + 42
</pre>

The <code>update_add_htlc</code> from B to C would be the same as the B->C direct
payment above.

*''A->D->C.'''' Finally, if for some reason A chose the more expensive route via D, it
would send the following <code>update_add_htlc</code> to D:

<pre>
* <code>amount_msat</code>: 5020398
* <code>cltv_expiry</code>: current-block-height + 40 + 9 + 42
* <code>onion_routing_packet</code>:
</pre>
	 * <code>amt_to_forward</code> = 4999999
     * <code>outgoing_cltv_value</code> = current-block-height + 9 + 42

And the <code>update_add_htlc</code> from D to C would be the same as the B->C
direct payment again.

===References===

[[https://i.creativecommons.org/l/by/4.0/88x31.png "License CC-BY"|alt=Creative Commons License]]
<br>
This work is licensed under a [http://creativecommons.org/licenses/by/4.0/ Creative Commons Attribution 4.0 International License].
