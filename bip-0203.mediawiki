==BOLT #3: Bitcoin Transaction and Script Formats==

This details the exact format of on-chain transactions, which both sides need to agree on to ensure signatures are valid. That is, the funding transaction output script, commitment transactions, and the HTLC transactions.

==Table of Contents==

<pre>
* [[#transactions|Transactions]]
  * [[#transaction-input-and-output-ordering|Transaction Input and Output Ordering]]
  * [[#use-of-segwit|Use of Segwit]]
  * [[#funding-transaction-output|Funding Transaction Output]]
  * [[#commitment-transaction|Commitment Transaction]]
      * [[#commitment-transaction-outputs|Commitment Transaction Outputs]]
      * [[#to_local-output|<code>to_local</code> Output]]
      * [[#to_remote-output|<code>to_remote</code> Output]]
      * [[#offered-htlc-outputs|Offered HTLC Outputs]]
      * [[#received-htlc-outputs|Received HTLC Outputs]]
      * [[#trimmed-outputs|Trimmed Outputs]]
  * [[#htlc-timeout-and-htlc-success-transactions|HTLC-timeout and HTLC-success Transactions]]
</pre>
	* [[#closing-transaction|Closing Transaction]]
    * [[#fees|Fees]]
        * [[#fee-calculation|Fee Calculation]]   
        * [[#fee-payment|Fee Payment]]
  * [[#keys|Keys]]
    * [[#key-derivation|Key Derivation]]
        * [[#localkey-remotekey-local_delayedkey-and-remote_delayedkey-derivation|<code>localkey</code>, <code>remotekey</code>, <code>local_htlckey</code>, <code>remote_htlckey</code>, <code>local_delayedkey</code>, and <code>remote_delayedkey</code> Derivation]]
        * [[#revocationkey-derivation|<code>revocationkey</code> Derivation]]
        * [[#per-commitment-secret-requirements|Per-commitment Secret Requirements]]
    * [[#efficient-per-commitment-secret-storage|Efficient Per-commitment Secret Storage]]
  * [[#appendix-a-expected-weights|Appendix A: Expected Weights]]    
      * [[#expected-weight-of-the-commitment-transaction|Expected Weight of the Commitment Transaction]]
      * [[#expected-weight-of-htlc-timeout-and-htlc-success-transactions|Expected Weight of HTLC-timeout and HTLC-success Transactions]]
  * [[#appendix-b-funding-transaction-test-vectors|Appendix B: Funding Transaction Test Vectors]]
  * [[#appendix-c-commitment-and-htlc-transaction-test-vectors|Appendix C: Commitment and HTLC Transaction Test Vectors]]
  * [[#appendix-d-per-commitment-secret-generation-test-vectors|Appendix D: Per-commitment Secret Generation Test Vectors]]
    * [[#generation-tests|Generation Tests]]
    * [[#storage-tests|Storage Tests]]
  * [[#appendix-e-key-derivation-test-vectors|Appendix E: Key Derivation Test Vectors]]
  * [[#references|References]]   
  * [[#authors|Authors]]   

==Transactions==

===Transaction Input and Output Ordering===

Lexicographic ordering: see [https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki BIP69].

===Use of Segwit===

Most transaction outputs used here are P2WSH outputs: the Segwit version of P2SH. To spend such outputs, the last item on the witness stack must be the actual script that was used to generate the P2WSH output that is being spent. This last item has been omitted for brevity in the rest of this document.

===Funding Transaction Output===

* The funding output script is a pay-to-witness-script-hash<sup>[https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program BIP141]</sup> to:
   * <code>2 <key1> <key2> 2 OP_CHECKMULTISIG</code>
* Where <code>key1</code> is the numerically lesser of the two DER-encoded <code>funding_pubkey</code> and <code>key2</code> is the greater.

===Commitment Transaction===

* version: 2
* locktime: upper 8 bits are 0x20, lower 24 bits are the lower 24 bits of the obscured commitment transaction number
* txin count: 1
   * <code>txin[0]</code> outpoint: <code>txid</code> and <code>output_index</code> from <code>funding_created</code> message
   * <code>txin[0]</code> sequence: upper 8 bits are 0x80, lower 24 bits are upper 24 bits of the obscured commitment transaction number
   * <code>txin[0]</code> script bytes: 0
   * <code>txin[0]</code> witness: <code>0 <signature_for_key1> <signature_for_key2></code>

The 48-bit commitment transaction number is obscured by <code>XOR</code> with the lower 48 bits of:

<pre>
SHA256(payment_basepoint from open_channel || payment_basepoint from accept_channel)
</pre>

This obscures the number of commitments made on the channel in the
case of unilateral close, yet still provides a useful index for both
nodes (who know the <code>payment_basepoint</code>s) to quickly find a revoked
commitment transaction.

====Commitment Transaction Outputs====

To allow an opportunity for penalty transactions, in case of a revoked commitment transaction, all outputs which return funds to the owner of the commitment transaction (a.k.a. "local node") must be delayed for <code>to_self_delay</code> blocks. This delay is done in a second stage HTLC transaction (HTLC-success for HTLCs accepted by the local node, HTLC-timeout for HTLCs offered by the local node).

The reason for the separate transaction stage for HTLC outputs is so that HTLCs can timeout or be fulfilled even though they are within the <code>to_self_delay</code> delay.
Otherwise, the required minimum timeout on HTLCs is lengthened by this delay, causing longer timeouts for HTLCs traversing the network.

The amounts for each output MUST be rounded down to whole satoshis. If this amount, minus the fees for the HTLC transaction, is less than the <code>dust_limit_satoshis</code> set by the owner of the commitment transaction, the output MUST NOT be produced (thus the funds add to fees).

=====<code>to_local</code> Output=====

This output sends funds back to the owner of this commitment transaction and thus must be timelocked using <code>OP_CSV</code>. It can be claimed, without delay, by the other party if they know the revocation key. The output is a version 0 P2WSH, with a witness script:

<pre>
OP_IF
    # Penalty transaction
    <revocationkey>
OP_ELSE
    <code>to_self_delay</code>
    OP_CSV
    OP_DROP
    <local_delayedkey>
OP_ENDIF
OP_CHECKSIG
</pre>

It is spent by a transaction with <code>nSequence</code> field set to <code>to_self_delay</code> (which can only be valid after that duration has passed), and witness:

	<local_delayedsig> 0

If a revoked commitment transaction is published, the other party can spend this output immediately with the following witness:

<pre>
<revocation_sig> 1
</pre>

=====<code>to_remote</code> Output=====

This output sends funds to the other peer and thus is a simple P2WPKH to <code>remotekey</code>.

=====Offered HTLC Outputs=====

This output sends funds to either a HTLC-timeout transaction after the HTLC-timeout or to the remote peer using the payment preimage or the revocation key. The output is a P2WSH, with a witness script:

<pre>
==To you with revocation key==
OP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationkey))> OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    <remote_htlckey> OP_SWAP OP_SIZE 32 OP_EQUAL
    OP_NOTIF
        # To me via HTLC-timeout transaction (timelocked).
        OP_DROP 2 OP_SWAP <local_htlckey> 2 OP_CHECKMULTISIG
    OP_ELSE
        # To you with preimage.
        OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF
</pre>

The remote node can redeem the HTLC with the witness:

<pre>
<remotehtlcsig> <payment_preimage>
</pre>

If a revoked commitment transaction is published, the remote node can spend this output immediately with the following witness:

<pre>
<revocation_sig> <revocationkey>
</pre>

The sending node can use the HTLC-timeout transaction to timeout the HTLC once the HTLC is expired, as shown below.

=====Received HTLC Outputs=====

This output sends funds to either the remote peer after the HTLC-timeout or using the revocation key, or to an HTLC-success transaction with a successful payment preimage. The output is a P2WSH, with a witness script:

<pre>
==To you with revocation key==
OP_DUP OP_HASH160 <RIPEMD160(SHA256(revocationkey))> OP_EQUAL
OP_IF
    OP_CHECKSIG
OP_ELSE
    <remote_htlckey> OP_SWAP
        OP_SIZE 32 OP_EQUAL
    OP_IF
        # To me via HTLC-success transaction.
        OP_HASH160 <RIPEMD160(payment_hash)> OP_EQUALVERIFY
        2 OP_SWAP <local_htlckey> 2 OP_CHECKMULTISIG
    OP_ELSE
        # To you after timeout.
        OP_DROP <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_CHECKSIG
    OP_ENDIF
OP_ENDIF
</pre>

To timeout the HTLC, the remote node spends it with the witness:

<pre>
<remotehtlcsig> 0
</pre>

If a revoked commitment transaction is published, the remote node can spend this output immediately with the following witness:

<pre>
<revocation_sig> <revocationkey>
</pre>

To redeem the HTLC, the HTLC-success transaction is used as detailed below.

====Trimmed Outputs====

Each peer specifies <code>dust_limit_satoshis</code> below which outputs should
not be produced; these outputs are termed "trimmed". A trimmed output is
considered too small to be worth creating and is instead added
to the commitment transaction fee. For HTLCs, it needs to be taken into
account that the second-stage HTLC transaction may also be below the
limit.

=====Requirements=====

The base fee:
  - before the commitment transaction outputs are determined:
    - MUST be subtracted from the <code>to_local</code> or <code>to_remote</code>
    outputs, as specified in [[#fee-calculation|Fee Calculation]].

The commitment transaction:
  - if the amount of the commitment transaction <code>to_local</code> output would be
less than <code>dust_limit_satoshis</code> set by the transaction owner:
    - MUST NOT contain that output.
  - otherwise:
    - MUST be generated as specified in [[#to-local-output|<code>to_local</code> Output]].
  - if the amount of the commitment transaction <code>to_remote</code> output would be
less than <code>dust_limit_satoshis</code> set by the transaction owner:
    - MUST NOT contain that output.
  - otherwise:
    - MUST be generated as specified in [[#to-remote-output|<code>to_remote</code> Output]].
  - for every offered HTLC:
    - if the HTLC amount minus the HTLC-timeout fee would be less than
    <code>dust_limit_satoshis</code> set by the transaction owner:
      - MUST NOT contain that output.
    - otherwise:
      - MUST be generated as specified in
      [[#offered-htlc-outputs|Offered HTLC Outputs]].
  - for every received HTLC:
    - if the HTLC amount minus the HTLC-success fee would be less than
    <code>dust_limit_satoshis</code> set by the transaction owner:
      - MUST NOT contain that output.
    - otherwise:
      - MUST be generated as specified in
      [[#received-htlc-outputs|Received HTLC Outputs]].

===HTLC-Timeout and HTLC-Success Transactions===

These HTLC transactions are almost identical, except the HTLC-timeout transaction is timelocked. The HTLC-timeout transaction is also the transaction which can be spent by a valid penalty transaction.

* version: 2
* locktime: <code>0</code> for HTLC-success, <code>cltv_expiry</code> for HTLC-timeout
* txin count: 1
   * <code>txin[0]</code> outpoint: <code>txid</code> of the commitment transaction and <code>output_index</code> of the matching HTLC output for the HTLC transaction
   * <code>txin[0]</code> sequence: <code>0</code>
   * <code>txin[0]</code> script bytes: <code>0</code>
   * <code>txin[0]</code> witness stack: <code>0 <remotehtlcsig> <localhtlcsig>  <payment_preimage></code> for HTLC-success, <code>0 <remotehtlcsig> <localhtlcsig> 0</code> for HTLC-timeout
* txout count: 1
   * <code>txout[[#fee-calculation|0]</code> amount: the HTLC amount minus fees (see [Fee Calculation]])
   * <code>txout[0]</code> script: version 0 P2WSH with witness script as shown below

The witness script for the output is:

<pre>
OP_IF
    # Penalty transaction
    <revocationkey>
OP_ELSE
    <code>to_self_delay</code>
    OP_CSV
    OP_DROP
    <local_delayedkey>
OP_ENDIF
OP_CHECKSIG
</pre>

To spend this via penalty, the remote node uses a witness stack <code><revocationsig> 1</code>, and to collect the output, the local node uses an input with nSequence <code>to_self_delay</code> and a witness stack <code><local_delayedsig> 0</code>.

===Closing Transaction===

Note that there are two possible variants for each node.

* version: 2
* locktime: 0
* txin count: 1
   * <code>txin[0]</code> outpoint: <code>txid</code> and <code>output_index</code> from <code>funding_created</code> message
   * <code>txin[0]</code> sequence: 0xFFFFFFFF
   * <code>txin[0]</code> script bytes: 0
   * <code>txin[0]</code> witness: <code>0 <signature_for_key1> <signature_for_key2></code>
* txout count: 0, 1 or 2
   * <code>txout</code> amount: final balance to be paid to one node (minus <code>fee_satoshis</code> from <code>closing_signed</code>, if this peer funded the channel)
   * <code>txout</code> script: as specified in that node's <code>scriptpubkey</code> in its <code>shutdown</code> message

====Requirements====

Each node offering a signature:
  - MUST subtract the fee given by <code>fee_satoshis</code> from the output to the funder.
  - MUST remove any output below its own <code>dust_limit_satoshis</code>.
  - MAY eliminate its own output.

====Rationale====

There is a possibility of irreparable differences on closing if one
node considers the other's output too small to allow propagation on
the Bitcoin network (a.k.a. "dust"), and that other node instead
considers that output too valuable to discard. This is why each
side uses its own <code>dust_limit_satoshis</code>, and the result can be a
signature validation failure, if they disagree on what the closing
transaction should look like.

However, if one side chooses to eliminate its own output, there's no
reason for the other side to fail the closing protocol; so this is
explicitly allowed. The signature indicates which variant
has been used.

There will be at least one output, if <code>dust_limit_satoshis</code> is greater
than twice the funding amount.

===Fees===

====Fee Calculation====

The fee calculation for both commitment transactions and HTLC
transactions is based on the current <code>feerate_per_kw</code> and the
*expected weight'' of the transaction.

The actual and expected weights vary for several reasons:

* Bitcoin uses DER-encoded signatures which vary in size.
* Bitcoin also uses variable-length integers, so a large number of outputs will take 3 bytes to encode rather than 1.
* The <code>to_remote</code> output may be below the dust limit.
* The <code>to_local</code> output may be below the dust limit once fees are extracted.

Thus, a simplified formula for ''expected weight'' is used, which assumes:

* Signatures are 73 bytes long (the maximum length).
* There are a small number of outputs (thus 1 byte to count them).
* There are always both a <code>to_local</code> output and a <code>to_remote</code> output.

This yields the following ''expected weights'' (details of the computation in [[#appendix-a-expected-weights|Appendix A]]):

<pre>
Commitment weight:   724 + 172 '' num-untrimmed-htlc-outputs
HTLC-timeout weight: 663
HTLC-success weight: 703
</pre>

Note the reference to the "base fee" for a commitment transaction in the requirements below, which is what the funder pays. The actual fee may be higher than the amount calculated here, due to rounding and trimmed outputs.

=====Requirements=====

The fee for an HTLC-timeout transaction:
  - MUST BE calculated to match:
    1. Multiply <code>feerate_per_kw</code> by 663 and divide by 1000 (rounding down).

The fee for an HTLC-success transaction:
  - MUST BE calculated to match:
    1. Multiply <code>feerate_per_kw</code> by 703 and divide by 1000 (rounding down).

The base fee for a commitment transaction:
  - MUST be calculated to match:
    1. Start with <code>weight</code> = 724.
    2. For each committed HTLC, if that output is not trimmed as specified in
    [[#trimmed-outputs|Trimmed Outputs]], add 172 to <code>weight</code>.
    3. Multiply <code>feerate_per_kw</code> by <code>weight</code>, divide by 1000 (rounding down).

=====Example=====

For example, suppose there is a <code>feerate_per_kw</code> of 5000, a <code>dust_limit_satoshis</code> of 546 satoshis, and a commitment transaction with:
* two offered HTLCs of 5000000 and 1000000 millisatoshis (5000 and 1000 satoshis)
* two received HTLCs of 7000000 and 800000 millisatoshis (7000 and 800 satoshis)

The HTLC-timeout transaction <code>weight</code> is 663, and thus the fee is 3315 satoshis.
The HTLC-success transaction <code>weight</code> is 703, and thus the fee is 3515 satoshis

The commitment transaction <code>weight</code> is calculated as follows:

* <code>weight</code> starts at 724.

* The offered HTLC of 5000 satoshis is above 546 + 3315 and results in:
  * an output of 5000 satoshi in the commitment transaction
  * a HTLC-timeout transaction of 5000 - 3145 satoshis which spends this output
  * <code>weight</code> increases to 896

* The offered HTLC of 1000 satoshis is below 546 + 3315 so is trimmed.

* The received HTLC of 7000 satoshis is above 546 + 3590 and results in:
  * an output of 7000 satoshi in the commitment transaction
  * a HTLC-success transaction of 7000 - 3590 satoshis which spends this output
  * <code>weight</code> increases to 1068

* The received HTLC of 800 satoshis is below 546 + 3515 so is trimmed.

The base commitment transaction fee is 5340 satoshi; the actual
fee (adding the 1000 and 800 satoshi HTLCs which would make dust
outputs) is 7140 satoshi. The final fee may be even higher if the
<code>to_local</code> or <code>to_remote</code> outputs fall below <code>dust_limit_satoshis</code>.

====Fee Payment====

Base commitment transaction fees are extracted from the funder's amount; if that amount is insufficient, the entire amount of the funder's output is used.

Note that if after the fee amount is subtracted from the to-funder output,
that output may be below <code>dust_limit_satoshis</code>, and thus will also
contribute to fees.

A node:
  - if the resulting fee rate is too low:
    - MAY fail the channel.

===Commitment Transaction Construction===

This section ties the previous sections together to detail the
algorithm for constructing the commitment transaction for one peer:
given that peer's <code>dust_limit_satoshis</code>, the current <code>feerate_per_kw</code>,
the amounts due to each peer (<code>to_local</code> and <code>to_remote</code>), and all
committed HTLCs:

1. Initialize the commitment transaction input and locktime, as specified
   in [[#commitment-transaction|Commitment Transaction]].
1. Calculate which committed HTLCs need to be trimmed (see [[#trimmed-outputs|Trimmed Outputs]]).
2. Calculate the base [[#fee-calculation|commitment transaction fee]].
3. Subtract this base fee from the funder (either <code>to_local</code> or <code>to_remote</code>),
   with a floor of 0 (see [[#fee-payment|Fee Payment]]).
3. For every offered HTLC, if it is not trimmed, add an
   [[#offered-htlc-outputs|offered HTLC output]].
4. For every received HTLC, if it is not trimmed, add an
   [[#received-htlc-outputs|received HTLC output]].
5. If the <code>to_local</code> amount is greater or equal to <code>dust_limit_satoshis</code>,
   add a [[#to-local-output|<code>to_local</code> output]].
6. If the <code>to_remote</code> amount is greater or equal to <code>dust_limit_satoshis</code>,
   add a [[#to-remote-output|<code>to_remote</code> output]].
7. Sort the outputs into [[#transaction-input-and-output-ordering|BIP 69 order]].

==Keys==

===Key Derivation===

Each commitment transaction uses a unique set of keys: <code>localkey</code> and <code>remotekey</code>.
The HTLC-success and HTLC-timeout transactions use <code>local_delayedkey</code> and <code>revocationkey</code>.
These are changed every time depending on the <code>per_commitment_point</code>.

The reason for key change is so that trustless watching for revoked
transactions can be outsourced. Such a _watcher_ should not be able to
determine the contents of a commitment transaction â€” even if the _watcher_ knows
which transaction ID to watch for and can make a reasonable guess
as to which HTLCs and balances may be included. Nonetheless, to
avoid storage of every commitment transaction, a _watcher_ can be given the
<code>per_commitment_secret</code> values (which can be stored compactly) and the
<code>revocation_basepoint</code> and <code>delayed_payment_basepoint</code> used to regenerate
the scripts required for the penalty transaction; thus, a _watcher_ need only be
given (and store) the signatures for each penalty input.

Changing the <code>localkey</code> and <code>remotekey</code> every time ensures that commitment
transaction ID cannot be guessed; every commitment transaction uses an ID
in its output script. Splitting the <code>local_delayedkey</code>, which is required for
the penalty transaction, allows it to be shared with the _watcher_ without
revealing <code>localkey</code>; even if both peers use the same _watcher_, nothing is revealed.

Finally, even in the case of normal unilateral close, the HTLC-success
and/or HTLC-timeout transactions do not reveal anything to the
_watcher_, as it does not know the corresponding <code>per_commitment_secret</code> and
cannot relate the <code>local_delayedkey</code> or <code>revocationkey</code> with their bases.

For efficiency, keys are generated from a series of per-commitment secrets
that are generated from a single seed, which allows the receiver to compactly
store them (see [[#efficient-per-commitment-secret-storage|below]]).

====<code>localkey</code>, <code>remotekey</code>, <code>local_htlckey</code>, <code>remote_htlckey</code>, <code>local_delayedkey</code>, and <code>remote_delayedkey</code> Derivation====

These keys are simply generated by addition from their base points:

	pubkey = basepoint + SHA256(per_commitment_point || basepoint) '' G

The <code>localkey</code> uses the local node's <code>payment_basepoint</code>; the <code>remotekey</code>
uses the remote node's <code>payment_basepoint</code>; the <code>local_delayedkey</code>
uses the local node's <code>delayed_payment_basepoint</code>; the <code>local_htlckey</code> uses the
local node's <code>htlc_basepoint</code>; and the <code>remote_delayedkey</code> uses the remote
node's <code>delayed_payment_basepoint</code>.

The corresponding private keys can be similarly derived, if the basepoint
secrets are known (i.e. <code>localkey</code>, <code>local_htlckey</code>, and <code>local_delayedkey</code> only):

<pre>
secretkey = basepoint_secret + SHA256(per_commitment_point || basepoint)
</pre>

====<code>revocationkey</code> Derivation====

The <code>revocationkey</code> is a blinded key: when the local node wishes to create a new
commitment for the remote node, it uses its own <code>revocation_basepoint</code> and the remote
node's <code>per_commitment_point</code> to derive a new <code>revocationkey</code> for the
commitment. After the remote node reveals (thereby revoking that commitment) the
<code>per_commitment_secret</code> used, the local node
can then derive the <code>revocationsecretkey</code>, as it now knows the two secrets
necessary to derive the key (<code>revocation_basepoint_secret</code> and
<code>per_commitment_secret</code>).

The <code>per_commitment_point</code> is generated using EC multiplication:

	per_commitment_point = per_commitment_secret '' G

And this is used to derive the revocation key from the remote node's
<code>revocation_basepoint</code>:

	revocationkey = revocation_basepoint '' SHA256(revocation_basepoint || per_commitment_point) + per_commitment_point '' SHA256(per_commitment_point || revocation_basepoint)

This construction ensures that neither the node providing the
basepoint nor the node providing the <code>per_commitment_point</code> can know the
private key without the other node's secret.

The corresponding private key can be derived once the <code>per_commitment_secret</code>
is known:

<pre>
revocationsecretkey = revocation_basepoint_secret '' SHA256(revocation_basepoint || per_commitment_point) + per_commitment_secret '' SHA256(per_commitment_point || revocation_basepoint)
</pre>

====Per-commitment Secret Requirements====

A node:
  - MUST select an unguessable 256-bit seed for each connection,
  - MUST NOT reveal the seed.

Up to 2^48 - 1 per-commitment secrets can be generated.

The first secret used:
  - MUST be index 281474976710655,
    - and from there, the index is decremented.

The I'th secret P:
  - MUST match the output of this algorithm:
